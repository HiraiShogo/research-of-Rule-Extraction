import sys
import numpy as np
import chainer
from chainer import cuda, Function, gradient_check, report, training, utils, Variable
from chainer import datasets, iterators, optimizers, serializers
from chainer.datasets import tuple_dataset
from chainer import Link, Chain, ChainList
import chainer.functions as F
import chainer.links as L
from chainer import training
from chainer.training import extensions
import cupy as cp
from collections import OrderedDict
import wx
from PIL import Image

class DNN(Chain):
    def __init__(self):
        super(DNN, self).__init__()
        self.output = {}
        with self.init_scope():
            #============================================================================
            #引数設定
            #
            #  L.Convolution2D((入力数), (出力数), (フィルタサイズ), stride =1, pad = 0)
            #  L.Linear((入力数), (出力数))
            #============================================================================

            self.conv1 = L.Convolution2D(1, 10, 5)
            self.conv2 = L.Convolution2D(10, 10, 8)
            self.conv3 = L.Convolution2D(10, 10, 16)
            self.affine1 = L.Linear(10, 10)
            self.affine2 = L.Linear(10, 10)

    def __call__(self, x):
        out = x
        self.output = {}
        #================================================================================
        #活性化関数設定
        #
        #  F.relu((入力))
        #  F.sigmoid((入力))
        #  F.max_pooling_2d((入力), (フィルタサイズ), stride = None, pad = 0)
        #  F.dropout((入力), ratio=.5)
        #================================================================================
        out = F.relu(self.conv1(out))
        self.output["Conv1"] = out.array
        out = F.relu(self.conv2(out))
        self.output["Conv2"] = out.array
        out = F.sigmoid(self.conv3(out))
        self.output["Conv3"] = out.array
        out = F.max_pooling_2d(out, 2)
        self.output["Pool"] = out.array
        out = F.sigmoid(self.affine1(out))
        self.output["Affine1"] = out.array
        self.output["Affine2"] = self.affine2(out).array
        return self.affine2(out)

    def get_output(self):
        return self.output



class Model:
    def __init__(self):
        self.params = None
        self.train, self.test = datasets.get_mnist(ndim=3)
        self.dnn = DNN()
        self.model = L.Classifier(self.dnn)
        self.size = None
        self.d = 0.004
        self.sigma = 0.1
        self.output_part = ""
        self.path = ""

    def train_Network(self, n_in, n_units, n_out, gd=0, e=50, bs=100, f=-1):
        self.params = {"gd":gd, "e":e, "bs":bs, "f":f, "n_in":n_in, "n_units":n_units, "n_out":n_out}
        chainer.cuda.get_device_from_id(0)
        self.model.to_gpu()

        optimizer = chainer.optimizers.Adam()
        optimizer.setup(self.model)

        train_iter = chainer.iterators.SerialIterator(self.train, self.params["bs"])
        test_iter = chainer.iterators.SerialIterator(self.test, self.params["bs"], repeat=False, shuffle=False)

        updater = training.StandardUpdater(train_iter, optimizer, device=self.params["gd"])
        trainer = training.Trainer(updater, (self.params["e"], 'epoch'))

        trainer.extend(extensions.Evaluator(test_iter, self.model,device=self.params["gd"]))
        trainer.extend(extensions.dump_graph('main/loss'))

        frequency = self.params["e"] if self.params["f"] == -1 else max(1, self.params["f"])
        trainer.extend(extensions.snapshot(), trigger=(frequency, 'epoch'))
        trainer.extend(extensions.LogReport())
        trainer.extend(
            extensions.PlotReport(['main/loss', 'validation/main/loss'],
                                  'epoch', file_name='loss.png'))
        trainer.extend(
            extensions.PlotReport(['main/accuracy', 'validation/main/accuracy'],
                                  'epoch', file_name='accuracy.png'))
        trainer.extend(extensions.PrintReport(
            ['epoch', 'main/loss', 'validation/main/loss',
             'main/accuracy', 'validation/main/accuracy', 'elapsed_time']))
        trainer.run()

    def save_Network(self):
        serializers.save_npz('my_mnist.npz', self.model)

    def load_Network(self,path =""):
        if path == "":
            app = wx.App()
            filter = "network file(*npz) | *.npz| All file(*.*) | *.*"
            dialog = wx.FileDialog(None, u'ネットワークファイルを選択してください', '', '', filter)
            dialog.ShowModal()
            path = dialog.GetPath()
        serializers.load_npz(path, self.model)
        chainer.cuda.get_device_from_id(0)
        self.model.to_gpu()

    def predict_Test(self, num):
        #print(np.array(self.test[0]).shape)
        prediction = self.model.predictor(cp.array(self.test[num][0][0]).reshape(1, 1, 28, 28))
        probability = chainer.cuda.to_cpu(F.softmax(prediction).data[0])
        np.set_printoptions(precision=20, floatmode='fixed', suppress=True)
        ans = self.dnn.get_output()
        ans["output"] = probability
        #print(probability)
        #print(self.dnn.get_output())
        return ans

    def predict_Train(self, num):
        #print(np.array(self.test[0]).shape)
        prediction = self.model.predictor(cp.array(self.train[num][0][0]).reshape(1, 1, 28, 28))
        probability = chainer.cuda.to_cpu(F.softmax(prediction).data[0])
        np.set_printoptions(precision=20, floatmode='fixed', suppress=True)
        self.ans = self.dnn.get_output()
        self.ans["output"] = probability
        #print(probability)
        #print(self.dnn.get_output())
        return self.ans